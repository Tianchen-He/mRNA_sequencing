---
title: "251010_curve_separation"
author: "Shangsi Lin"
date: "2025-11-04"
output: html_document
---
WARNING: DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING.
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(writexl)

# Add the function for ppm calculation
ppm = function(observed, theo){
  if(abs((observed - theo) / theo * 10^6) > 10) {
    return(FALSE)
  } else {
    return(TRUE)
  }
}

source("../Source/introduction.R")
source("../Source/blind_seq.R")
source("../Source/plotting.R")
source("../Source/advanced_plotting.R")

# get your dictionary file ready
dictionary = read_xlsx("../Data/uni_dictionary.xlsx")
options(scipen = 999)
```

```{r df_load}
set_up("mRNA", "UUUUUUUUUUUUUUUUUUUU", "../Data/Pure_AD/NistmRNA_15min_1st_Mistake_251010_JYL.xlsx", "peptide", 24000, 0, 18)
plot_mass_rt(df, FALSE, 18)



df_layer_1 <- df %>%
  filter(
    (apex_rt >= 14) |
    (apex_rt > 12 & monoisotopic_mass < 10000) |
    (apex_rt > 10 & monoisotopic_mass < 9000) |
    (apex_rt > 8 & monoisotopic_mass < 5000) |
    (apex_rt > 4 & monoisotopic_mass < 3800) |
    (monoisotopic_mass < 2500)
  )

plot_mass_rt(df_layer_1, FALSE, 18)


df_layer_2 <- df %>%
  filter(
    (apex_rt <= 14 & monoisotopic_mass > 10000) |
    (apex_rt <= 12 & monoisotopic_mass > 7500) |
    (apex_rt <= 10 & monoisotopic_mass > 5000) |
    (apex_rt <= 8)
  )

df_layer_2 <- df_layer_2 %>%
  filter(
    (apex_rt > 10 | monoisotopic_mass < 7500) &
    (apex_rt > 8 | monoisotopic_mass < 6250)
  )


plot_mass_rt(df_layer_2, FALSE, 18)

df_layer_3 <- df %>%
  filter(
    (apex_rt <= 10 & monoisotopic_mass > 7500) |
    (apex_rt <= 8 & monoisotopic_mass > 5000) |
    (apex_rt <= 5.8 & monoisotopic_mass > 3750) |
    (apex_rt <= 4 & monoisotopic_mass > 3250) |
    (apex_rt <= 2)
  )

plot_mass_rt(df_layer_3, FALSE, 18)
```

```{r}
# training upper curve
upper_training = data.frame(
  monoisotopic_mass = c(
    19663.878, 19028.817, 17720.631, 16755.497, 15454.299,
    13839.107, 13204.038, 9261.209, 8224.155, 7156.054,
    5339.803, 3848.557, 2909.419, 2602.372, 1974.318
  ),
  apex_rt = c(
    15.3334, 15.2428, 15.211, 14.998, 14.9391,
    14.608, 14.4627, 12.2101, 11.7015, 10.6216,
    9.207, 7.0791, 4.9818, 3.328, 1.7695
  )
)

ggplot(upper_training, aes(x = monoisotopic_mass, y = apex_rt)) +
  geom_point(size = 3, color = "blue") +        # 画点
  theme_minimal() +                             # 简洁主题
  labs(
    title = "Upper Training Points",
    x = "Monoisotopic Mass",
    y = "Apex RT"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14)
  )
```
```{r attemp_model_failed}
## =========================
## 1) Fit the upper curve
## =========================
fit_upper_model <- function(df, df_spline = NULL, spar = NULL) {
  stopifnot(all(c("monoisotopic_mass", "apex_rt") %in% names(df)))
  df <- df[order(df$monoisotopic_mass), ]
  
  # Build args only if not NULL
  args <- list(x = df$monoisotopic_mass, y = df$apex_rt)
  if (!is.null(df_spline)) args$df   <- df_spline
  if (!is.null(spar))      args$spar <- spar
  
  ss <- do.call(stats::smooth.spline, args)
  structure(list(spline = ss), class = "upper_curve_model")
}

## =========================
## 2) Predict f(x) (+ SE)
## =========================
predict_upper <- function(model, x_new, se = TRUE) {
  stopifnot(inherits(model, "upper_curve_model"))
  # handle non-finite x gracefully
  keep <- is.finite(x_new)
  n <- length(x_new)
  fhat <- rep(NA_real_, n)
  seout <- rep(NA_real_, n)
  
  if (any(keep)) {
    p <- predict(model$spline, x = x_new[keep], se = se, outer.ok = TRUE)
    fhat[keep] <- p$y
    if (se && !is.null(p$se)) seout[keep] <- p$se
  }
  data.frame(x = x_new, fhat = fhat, se = if (se) seout else NA_real_)
}

## ====================================================
## 3) Classify with a fuzzy band around the curve f(x)
##    mode = "abs": half-band = value (apex_rt units)
##    mode = "se" : half-band = k * SE(x)
## ====================================================
classify_points <- function(model, new_df,
                            mode = c("abs", "se"),
                            value = 0.2,  # if mode="abs"
                            k = 2.0,      # if mode="se"
                            fuzzy_as_upper = FALSE  # TRUE to treat "Both" as upper
) {
  mode <- match.arg(mode)
  stopifnot(all(c("monoisotopic_mass", "apex_rt") %in% names(new_df)))
  
  pred <- predict_upper(model, new_df$monoisotopic_mass, se = TRUE)
  d <- new_df$apex_rt - pred$fhat
  
  if (mode == "abs") {
    sigma_y <- rep(value, nrow(new_df))
  } else {
    se_vec <- pred$se
    if (all(!is.finite(se_vec))) {
      # fallback if SE unavailable
      med_scale <- stats::mad(new_df$apex_rt, na.rm = TRUE)
      se_vec <- rep(med_scale, nrow(new_df))
    } else {
      med <- stats::median(se_vec[is.finite(se_vec)], na.rm = TRUE)
      se_vec[!is.finite(se_vec)] <- med
    }
    sigma_y <- k * se_vec
  }
  
  label3 <- rep(NA_character_, nrow(new_df))
  ok <- is.finite(d) & is.finite(sigma_y)
  label3[ ok & (d >  sigma_y) ] <- "Upper"
  label3[ ok & (d < -sigma_y) ] <- "Lower"
  label3[ ok & (abs(d) <= sigma_y) ] <- "Both"
  
  # Map to 2 groups
  if (isTRUE(fuzzy_as_upper)) {
    group2 <- ifelse(label3 %in% c("Upper","Both"), "upper", "middle and lower")
  } else {
    group2 <- ifelse(label3 == "Upper", "upper", "middle and lower")
  }
  
  cbind(new_df,
        fhat = pred$fhat,
        residual = d,
        band = sigma_y,
        label3 = label3,
        group = group2,
        stringsAsFactors = FALSE)
}

## =========================
## 4) Example usage
## =========================
## Assuming you already created `upper_training` exactly as you posted:
## upper_training <- data.frame(monoi... , apex_rt = ...)

upper_model <- fit_upper_model(upper_training)

## Example: classify a single point (10000, 20)
one_pt <- data.frame(monoisotopic_mass = 10000, apex_rt = 20)
temp = classify_points(upper_model, df, mode = "se", k = 2.0, fuzzy_as_upper = FALSE)

## Example: classify a whole data frame df (must have the two columns)
## df <- your_dataframe
## out <- classify_points(upper_model, df, mode = "se", k = 2.0, fuzzy_as_upper = FALSE)
## head(out)

ggplot(temp, aes(x = monoisotopic_mass, y = apex_rt, color = group)) +
  geom_point(size = 3) +        # 画点
  theme_minimal() +                             # 简洁主题
  labs(
    title = "Upper Training Points",
    x = "Monoisotopic Mass",
    y = "Apex RT"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14)
  )
```

```{r}
dictionary = dictionary[c(1, 2, 3, 4),]

# first variable: your data frame
# second variable: your dictionary
algorithm_output = blind_seq(df_layer_3, dictionary)

# first variable: the output data frame from nested algorithm
# second variable: the minimum length for ladders you want to include in your result file
# third variable: the location of your original data file
remotely_output_ladders_found(algorithm_output, 3,  file_location)

plot_ladders("../Result/LSS/Curve1_blind_sequencing_result_point_version.xlsx")
ggsave(
  filename = "curve1.png",  
  width = 30,                  
  height = 15,               
  dpi = 300                  
)

plot_ladders("../Result/LSS/Curve2_blind_sequencing_result_point_version.xlsx")
ggsave(
  filename = "curve2.png",  
  width = 30,                  
  height = 15,               
  dpi = 300                  
)

plot_ladders("../Result/LSS/Curve3_blind_sequencing_result_point_version.xlsx")
ggsave(
  filename = "curve3.png",  
  width = 30,                  
  height = 15,               
  dpi = 300                  
)
```

